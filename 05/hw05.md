1. 简述混合高斯模型的基本原理，以及通过混合高斯模型进行背景建模的基本思想。 
答：我们用帧差法检测运动目标，视频中像素灰度在时间方向上的变化，符合高斯分布。如果像素在当前帧上的灰度，比上一帧灰度，变化量大于阀值T，我们就认为这个像素处于前景中；如果变化量小于前一帧，则处于背景。
![帧差法运动目标检测公式]()

但是这种方法有两个重大缺点，一是相邻两帧运动目标相减，目标内容空洞，不利于后面分析。二是前后两帧相减，图片噪声变大，不利于检测目标。
如果把某一段时间内像素灰度变化做一个统计，能发现灰度在某一个均值周围变化。这个分布符合高斯分布。这时候一个像素灰度值超过均值3倍sigma，这个像素有极大概率是前景。如果没超过，极大概率是背景。
![检测某像素灰度值是否符合高斯分布]()

但实际情况中，一个高斯模型往往并不能刻画某一个像素的变化。这时候，我们用混合高斯模型来描述。任何一个分布函数，都可以看做多个高斯分布的线性加权组合。即，任一个分布函数，都可以用权重不同的高斯分布累加而成。

同理，图像中像素的灰度分布，也由多个不同权重的高斯分布组合而成。
混合高斯模型背景建模，一般通过这几个步骤：

1. 模型初始化，将采到的第一帧图像像素灰度值作为均值,再赋予较大方差.比如初始Q=1,w=1.0.

2. 模型学习,将当前帧的对应点q的像素的灰度值与已有的Q个高斯模型作比较,若q的灰度值与对应均值u差小于2.5sigma,则该像素属于背景,就按上页方式调整q的高斯模型参数与权重.

3. 如果不满足条件,该像素是前景,并且q<Q,则增加一个新分量;若q=Q则替换;

4. 如果第一步中没有任何模式被匹配,那权重最小的模式就被替换,即该模式的均值为当前像素值,标准差为初始较大值,权重为较小值;

5. 各模式按照权重/标准差排序,权重大/标准差小的模式靠前列;

6. 取前B个模式作为背景,最小的前b个模式,其重之和大于T,T表示背景所占比例.




2. 解释光流计算中的恒定亮度假设，进一步简述L-K光流估计方法的基本原理。 
答:光流是一种运动模式，这种运动模式指的是一个物体、表面、边缘在一个视角下由一个观察者（比如眼睛、摄像头等）和背景之间形成的明显移动。光流技术，如运动检测和图像分割，时间碰撞，运动补偿编码，三维立体视差，都是利用了这种边缘或表面运动的技术。
二维图像的移动相对于观察者而言是三维物体移动的在图像平面的投影。有序的图像可以估计出二维图像的瞬时图像速率或离散图像转移。
光流算法评估了两幅图像的之间的变形，它的基本假设是体素和图像像素守恒。它假设一个物体的颜色在前后两帧没有巨大而明显的变化。基于这个思路，我们可以得到图像约束方程。

亮度恒定，就是同一点随着时间的变化，其亮度不会发生改变。这是基本光流法的假定（所有光流法变种都必须满足），用于得到光流法基本方程.


L-k算法假设:
1. 亮度恒定，就是同一点随着时间的变化，其亮度不会发生改变。这是基本光流法的假定（所有光流法变种都必须满足），用于得到光流法基本方程；

2. 小运动，这个也必须满足，就是时间的变化不会引起位置的剧烈变化，这样灰度才能对位置求偏导（换句话说，小运动情况下我们才能用前后帧之间单位位置变化引起的灰度变化去近似灰度对位置的偏导数），这也是光流法不可或缺的假定；

3. 空间一致，一个场景上邻近的点投影到图像上也是邻近点，且邻近点速度一致。这是Lucas-Kanade光流法特有的假定，因为光流法基本方程约束只有一个，而要求x，y方向的速度，有两个未知变量。我们假定特征点邻域内做相似运动，就可以连立n多个方程求取x，y方向的速度（n为特征点邻域总点数，包括该特征点）。

它计算两帧在时间t 到t + δt之间每个每个像素点位置的移动。 由于它是基于图像信号的泰勒级数，这种方法称为差分，这就是对于空间和时间坐标使用偏导数。

图像约束方程可以写为:
I(x,y,z,t)=I(x+δx,y+δy,z+δz,t+δt) I (x ,y ,z ,t ) = I (x + δx ,y + δy ,z + δz ,t + δt )I(x,y,z,t)=I(x+δx,y+δy,z+δz,t+δt)
I(x, y,z, t) 为在（x,y,z）位置的体素。

我们假设移动足够的小，那么对图像约束方程使用泰勒公式，我们可以得到：
I(x+δx,y+δy,z+δz,t+δt)=I(x,y,z,t)+∂I∂xδx+∂I∂yδy+∂I∂zδz+∂I∂tδt+H.O.T. I(x+\delta x,y+\delta y,z+\delta z,t+\delta t) = I(x,y,z,t) + \frac{\partial I}{\partial x}\delta x+\frac{\partial I}{\partial y}\delta y+\frac{\partial I}{\partial z}\delta z+\frac{\partial I}{\partial t}\delta t+H.O.T.I(x+δx,y+δy,z+δz,t+δt)=I(x,y,z,t)+ 
∂x
∂I
​	
 δx+ 
∂y
∂I
​	
 δy+ 
∂z
∂I
​	
 δz+ 
∂t
∂I
​	
 δt+H.O.T.
H.O.T. 指更高阶，在移动足够小的情况下可以忽略。
从这个方程中我们可以得到：

∂I∂xδx+∂I∂yδy+∂I∂zδz+∂I∂tδt=0 \frac{\partial I}{\partial x}\delta x+\frac{\partial I}{\partial y}\delta y+\frac{\partial I}{\partial z}\delta z+\frac{\partial I}{\partial t}\delta t = 0 
∂x
∂I
​	
 δx+ 
∂y
∂I
​	
 δy+ 
∂z
∂I
​	
 δz+ 
∂t
∂I
​	
 δt=0

或者

∂I∂xδxδt+∂I∂yδyδt+∂I∂zδzδt+∂I∂tδtδt=0 \frac{\partial I}{\partial x}\frac{\delta x}{\delta t}+\frac{\partial I}{\partial y}\frac{\delta y}{\delta t}+\frac{\partial I}{\partial z}\frac{\delta z}{\delta t}+\frac{\partial I}{\partial t}\frac{\delta t}{\delta t} = 0 
∂x
∂I
​	
  
δt
δx
​	
 + 
∂y
∂I
​	
  
δt
δy
​	
 + 
∂z
∂I
​	
  
δt
δz
​	
 + 
∂t
∂I
​	
  
δt
δt
​	
 =0

进而得到

∂I∂xVx+∂I∂yVy+∂I∂zVz+∂I∂t=0 \frac{\partial I}{\partial x}V_x+\frac{\partial I}{\partial y}V_y+\frac{\partial I}{\partial z}V_z+\frac{\partial I}{\partial t} = 0 
∂x
∂I
​	
 V 
x
​	
 + 
∂y
∂I
​	
 V 
y
​	
 + 
∂z
∂I
​	
 V 
z
​	
 + 
∂t
∂I
​	
 =0

Vx,Vy,Vz分别是I(x,y,z,t)的光流向量中x，y，z的组成。 ∂I∂x \frac{\partial I}{\partial x} 
∂x
∂I
​	
 , ∂I∂y \frac{\partial I}{\partial y} 
∂y
∂I
​	
 , ∂I∂z \frac{\partial I}{\partial z} 
∂z
∂I
​	
 和 ∂I∂t \frac{\partial I}{\partial t} 
∂t
∂I
​	
 则是图像在(x,y,z,t)这一点向相应方向的差分。
所以：

IxVx+IyVy+IzVz=−It I_xV_x + I_yV_y + I_zV_z= − I_tI 
x
​	
 V 
x
​	
 +I 
y
​	
 V 
y
​	
 +I 
z
​	
 V 
z
​	
 =−I 
t
​	
 

写做：

∇IT⋅V⃗ =−It \nabla I^T\cdot\vec{V} = -I_t∇I 
T
 ⋅ 
V
 =−I 
t
​	
 

这个方程有三个未知量，尚不能被解决，这也就是所谓光流算法的光圈问题。那么要找到光流向量则需要另一套解决的方案。而Lucas-Kanade算法是一个非迭代的算法：

假设流(Vx,Vy,Vz)在一个大小为mmm(m>1)的小窗中是一个常数，那么从像素1…n, n=m3 n = m^3n=m 
3
 中可以得到下列一组方程

Ix1Vx+Iy1Vy+Iz1Vz=−It1 I_{x_1} V_x + I_{y_1} V_y + I_{z_1} V_z = -I_{t_1}I 
x 
1
​	
 
​	
 V 
x
​	
 +I 
y 
1
​	
 
​	
 V 
y
​	
 +I 
z 
1
​	
 
​	
 V 
z
​	
 =−I 
t 
1
​	
 
​	
 
Ix2Vx+Iy2Vy+Iz2Vz=−It2 I_{x_2} V_x + I_{y_2} V_y + I_{z_2} V_z = -I_{t_2}I 
x 
2
​	
 
​	
 V 
x
​	
 +I 
y 
2
​	
 
​	
 V 
y
​	
 +I 
z 
2
​	
 
​	
 V 
z
​	
 =−I 
t 
2
​	
 
​	
 
⋮ \vdots⋮
IxnVx+IynVy+IznVz=−Itn I_{x_n} V_x + I_{y_n} V_y + I_{z_n} V_z = -I_{t_n}I 
x 
n
​	
 
​	
 V 
x
​	
 +I 
y 
n
​	
 
​	
 V 
y
​	
 +I 
z 
n
​	
 
​	
 V 
z
​	
 =−I 
t 
n
​	
 
​	
 

三个未知数但是有多于三个的方程，这个方程组自然是个超定方程，也就是说方程组内有冗余，方程组可以表示为：

⎡⎣⎢⎢⎢⎢⎢Ix1Ix2⋮IxnIy1Iy2⋮IynIz1Iz2⋮Izn⎤⎦⎥⎥⎥⎥⎥⎡⎣⎢⎢⎢VxVyVz⎤⎦⎥⎥⎥=⎡⎣⎢⎢⎢⎢−It1−It2⋮−Itn⎤⎦⎥⎥⎥⎥ \begin{bmatrix}I_{x_1} & I_{y_1} & I_{z_1}\\I_{x_2} & I_{y_2} & I_{z_2}\\\vdots & \vdots & \vdots\\I_{x_n} & I_{y_n} & I_{z_n}\end{bmatrix} \begin{bmatrix}V_x\\V_y\\V_z \end{bmatrix}= \begin{bmatrix}-I_{t_1}\\ -I_{t_2}\\ \vdots \\-I_{t_n}\end{bmatrix} 
⎣
⎢
⎢
⎢
⎡
​	
  
I 
x 
1
​	
 
​	
 
I 
x 
2
​	
 
​	
 
⋮
I 
x 
n
​	
 
​	
 
​	
  
I 
y 
1
​	
 
​	
 
I 
y 
2
​	
 
​	
 
⋮
I 
y 
n
​	
 
​	
 
​	
  
I 
z 
1
​	
 
​	
 
I 
z 
2
​	
 
​	
 
⋮
I 
z 
n
​	
 
​	
 
​	
  
⎦
⎥
⎥
⎥
⎤
​	
  
⎣
⎡
​	
  
V 
x
​	
 
V 
y
​	
 
V 
z
​	
 
​	
  
⎦
⎤
​	
 = 
⎣
⎢
⎢
⎢
⎡
​	
  
−I 
t 
1
​	
 
​	
 
−I 
t 
2
​	
 
​	
 
⋮
−I 
t 
n
​	
 
​	
 
​	
  
⎦
⎥
⎥
⎥
⎤
​	
 

记作：Av⃗ =−b A\vec{v}=-bA 
v
 =−b

为了解决这个超定问题，我们采用最小二乘法：

ATAv⃗ =AT(−b) A^TA\vec{v}=A^T(-b)A 
T
 A 
v
 =A 
T
 (−b)

v⃗ =(ATA)−1AT(−b) \vec{v}=(A^TA)^{-1}A^T(-b) 
v
 =(A 
T
 A) 
−1
 A 
T
 (−b)

得到：

⎡⎣⎢⎢⎢VxVyVz⎤⎦⎥⎥⎥=⎡⎣⎢⎢⎢∑I2xi∑IxiIyi∑IxiIzi∑IxiIyi∑I2yi∑IyiIzi∑IxiIzi∑IyiIzi∑I2zi⎤⎦⎥⎥⎥−1⎡⎣⎢⎢⎢−∑IxiIti−∑IyiIti−∑IziIti⎤⎦⎥⎥⎥ \begin{bmatrix}V_x\\V_y\\V_z \end{bmatrix} =\begin{bmatrix}\sum I_{x_i}^2 &\sum I_{x_i}I_{y_i} & \sum I_{x_i}I_{z_i} \\\sum I_{x_i}I_{y_i} & \sum I_{y_i}^2 & \sum I_{y_i}I_{z_i} \\\sum I_{x_i}I_{z_i} & \sum I_{y_i}I_{z_i} & \sum I_{z_i}^2 \\\end{bmatrix}^{-1}\begin{bmatrix}-\sum I_{x_i}I_{t_i} \\-\sum I_{y_i}I_{t_i} \\-\sum I_{z_i}I_{t_i}\end{bmatrix} 
⎣
⎡
​	
  
V 
x
​	
 
V 
y
​	
 
V 
z
​	
 
​	
  
⎦
⎤
​	
 = 
⎣
⎡
​	
  
∑I 
x 
i
​	
 
2
​	
 
∑I 
x 
i
​	
 
​	
 I 
y 
i
​	
 
​	
 
∑I 
x 
i
​	
 
​	
 I 
z 
i
​	
 
​	
 
​	
  
∑I 
x 
i
​	
 
​	
 I 
y 
i
​	
 
​	
 
∑I 
y 
i
​	
 
2
​	
 
∑I 
y 
i
​	
 
​	
 I 
z 
i
​	
 
​	
 
​	
  
∑I 
x 
i
​	
 
​	
 I 
z 
i
​	
 
​	
 
∑I 
y 
i
​	
 
​	
 I 
z 
i
​	
 
​	
 
∑I 
z 
i
​	
 
2
​	
 
​	
  
⎦
⎤
​	
  
−1
  
⎣
⎡
​	
  
−∑I 
x 
i
​	
 
​	
 I 
t 
i
​	
 
​	
 
−∑I 
y 
i
​	
 
​	
 I 
t 
i
​	
 
​	
 
−∑I 
z 
i
​	
 
​	
 I 
t 
i
​	
 
​	
 
​	
  
⎦
⎤
​	
 

其中的求和是从1到n。

这也就是说寻找光流可以通过在四维上图像导数的分别累加得出。我们还需要一个权重函数W(i,j,k) W(i, j,k)W(i,j,k)， i,j,k∈[1,m] i,j,k \in [1,m]i,j,k∈[1,m]来突出窗口中心点的坐标。

这个算法的不足在于它不能产生一个密度很高的流向量，例如在运动的边缘和黑大的同质区域中的微小移动方面流信息会很快的褪去。它的优点在于有噪声存在的鲁棒性还是可以的。



